## IMT Order : distributed transactors 

# Overview

This project is a sandbox for simulating an Order Management System (OMS) using mix application. It includes modules for managing orders from ecommerce websites, simulating workflows, and analyzing performance. Its main feature, is the ability to distribute the order management tasks among multiple erlang nodes enabling parallelism of tasks. 

## How It Works

The application follows a distributed order processing workflow:

1. **Order Creation Flow**:
   - The e-commerce frontend simulator (`eComFront`) generates order requests and sends them to the OMS API (port 9090)
   - The API receives the order and uses a **hash ring** to determine which node should handle the order based on the order ID
   - The selected node's `TransactorDynamicSupervisor` spawns a `TransactorServer` process (one per order) to manage the order lifecycle
   - The transactor finds an available store with all required products in stock and stores the order

2. **Payment Processing**:
   - After a delay, the frontend simulator sends a payment callback to the OMS API
   - The API routes the payment to the same node that handled the order (using the hash ring)
   - The transactor processes the payment, updates the order with transaction details, and sends it to the WMS backend for delivery processing

3. **Node Distribution**:
   - A **consistent hash ring** distributes orders across available nodes
   - When nodes join or leave the cluster, the hash ring automatically updates
   - Each order is consistently routed to the same node based on its ID, ensuring order state consistency

4. **Simulation Components**:
   - **WMS Simulator**: Generates stock data and receives order processing requests (port 9091)
   - **Stats Collection**: Periodically collects and aggregates sales statistics
   - **Performance Logging**: All API requests are logged to `data/stats.csv` for analysis

5. **Data Persistence**:
   - Orders, stocks, and statistics are stored in a file-based hash table (`MicroDb`)
   - Data is organized in a directory structure based on hash values for efficient access

## Features

1. **Hash Ring Distribution**: Dynamically allocate orders to nodes using a consistent hash ring for efficient load balancing.
2. **End-to-End Simulation**: Run comprehensive simulations of e-commerce frontends and warehouse management system (WMS) backends.
3. **Fault Tolerance**: Leverage supervision trees, supervisors, and dynamic supervisors to ensure robustness and system resilience.
4. **API Error Handling**: Implement a retry mechanism to gracefully handle failed HTTP requests and improve reliability.

## Project Structure

1. **`config/`**: Contains configuration files for application settings and environment-specific parameters.
   
2. **`lib/`**: The core source code of the project, organized by functional modules:
   - **`OMS/`**: Handles order management logic.
     - **`OrderDistributor/`**: Implements the consistent hash ring for order distribution.
     - **`Transactor/`**: Manages transaction logic for order processing.
     - **`order_api.ex`**: Core business logic for the order management system (OMS).
   - **`eComFront/`**: Simulates the frontend of the e-commerce platform.
   - **`WMS/`**: Simulates the backend of the warehouse management system (WMS).
   - **`utils/`**: Utility functions for common tasks like error handling and API communication.

3. **`data/`**: Directory for storing data generated by simulations (created automatically when the application starts).
4. **`simulation_analysis.ipynb`**: Jupyter notebook for analyzing simulation results.


# How to run : 

To run the program and observe its different features you can run the following commands : 

## 1. Launch the main simulation: 

First, start the main simulation responsible for distributing the orders to the available nodes. 

    ``` bash
    iex --sname sim-master -S mix
    ```
**`IMPORTANT NOTE`** : Be sure to add the `-master` suffix to the name of the main node. This way, the applications launches the simulation and it will be designated as the main node. 

The simulation will run and you can observe the logs to see the current workflow. 

## 2. Launch additional nodes for load balancing:

Next, you can start other nodes to improve order management. These nodes will be able to start processes to manage workload shared by the master node. 

In a new terminal execute the command : 

    ``` bash
    iex --sname sim-worker -S mix
    ```
**`IMPORTANT NOTE`** : For the workers nodes, you can optionally specify the suffix "-worker" or the application will fall back to its default implementation (a worker node). 

This command will only launch the `TransactorDynamicSupervisor` to manage received orders from the master node. 

## 3. Connect nodes:

During the main simulation, you can connect the worker nodes to the master node. A log message will be printed in the main terminal, indicating that the master has successfully taken into account the added node. 

In the worker node terminal you can run the following : 

    ``` bash
    iex(sim-worker@hostname)1> Node.connect(:"sim-master@hostname")
    ```
**`IMPORTANT NOTE`** : Replace `hostname` with the actual hostname of your machine. The node names (`sim-master` and `sim-worker`) should match the names you used when starting the nodes with `--sname`. 

## 4. Removing nodes: 

In the same way we added nodes, we can also remove them. You will notice a log message in the main terminal notifying you of this modification. 

In the worker node terminal you can run the following : 

    ``` bash
    iex(sim-worker@hostname)1> Node.disconnect(:"sim-master@hostname")
    ```
**`IMPORTANT NOTE`** : Replace `hostname` with the actual hostname of your machine. The node names (`sim-master` and `sim-worker`) should match the names you used when starting the nodes with `--sname`. 



